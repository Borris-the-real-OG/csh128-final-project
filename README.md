## Presented by `Fe`tching
*(better Rust/iron pun TBA)*
- George Huebner (georgeh3)

# So Long Bevy

[![](https://img.youtube.com/vi/M1vfXoUNDYA/0.jpg)](https://www.youtube.com/watch?v=M1vfXoUNDYA)

*We've got a great name, a great team, and a GREAT name. Let's pivot!*

I have decided not to proceed with my original idea of designing a game in Bevy. There are a few reasons for this decision:

1. Bevy's ECS is cool and all, but from everything I've seen, I wouldn't really be leveraging Rust itself when making a game using an existing framework: I would be writing Bevy code, not Rust code.
    * I would really like to explore building a game from the ground up (in Rust) in the future, but this is a significantly larger endeavor than can be accomplished in a semester project.
2. The Rust gamedev ecosystem has yet to reach maturity. I, too, like to live life on the bleeding edge sometimes, but having all dependencies break each other gets very tiring very quickly.
3. I could feasibly make a prototype, but likely not one that I would actually be happy with. I knew the asset pipeline would be bad, but I underestimated that even ripping assets from existing games would still be a lot of work.

Intstead, I will be working on a compatibility layer for the Tectonic typesetting system. Why Tectonic?

1. It's open source â€” Other people can actually use my code, and it might even get merged upstream!
2. It solves a problem. I'm no stranger to building useless things, but having something hat I can benefit from motivates me to actually make the project good.
3. It uses Rust. Well, no duh, Bevy uses Rust too, but the whole purpose of Tectonic is to provide a safe, platform-independent wrapper over the $\LaTeX$ wrappers of yore. It makes sense to write this project in Rust: I can claim moral superiority over C# users now!

<br>

![](Untitled.png)


## Design Process
So, here's the main problem. This is taken from an XDV file generated by XeTeX **from MacTex**:

```/usr/local/texlive/2022/texmf-dist/fonts/opentype/public/lm/lmroman10-regular.otf```

And here is an exerpt of Tectonic's XDV (both from the same $\LaTeX$ source):

```lmroman10-regular```

See the issue? The XDV Tectonic generates can only be understood by Tectonic --- this makes sense, because this is how $\LaTeX$ is passed around internally in Tectonic. However, this XDV file is completely useless outside of Tectonic, because `lmroman10-regular` doesn't mean anything by itself. One of the cool things about Tectonic is that, like Cargo, it will automatically pull dependencies for your Latex documents from the internet when you compile your document. However, unlike most TeX distributions which store assets in a human-readable format, Tectonic instead caches <u>all</u> assets like Git objects. Let's compare the actual `lmroman10-regular` files on my machine between MacTex and Tectonic:

```$ md5 -q /usr/local/texlive/2022/texmf-dist/fonts/opentype/public/lm/lmroman10-regular.otf
ae9d1b331000d544f47e5223081b7b54
$ for i in ~/Library/Caches/Tectonic/files/*/*; do if [ "`md5 -q $i`" = "ae9d1b331000d544f47e5223081b7b54" ]; then echo $i; fi; done
~/Library/Caches/Tectonic/files/1a/a18cfefa58132c52ce5de70db1fd1154201c19cd2b2cdaffba4906a33e6852
```
This tells us one good piece of news that makes our lives easier: the assets are identical in both MacTex and Tectonic.

### Option 1: Try and overwrite filepath in XDV manually
I would rather castrate myself with a rusty metal rod.

### Option 2: `ls-R` database craziness
Buckle your seatbelts, because we're about to go take a trip on the magic schoolbus back to the wild west of the early days of Tex. Back in the 90s, every TeX library used their own path searching algorithm (many of which were error prone), so Karl Berry made Karl's Path Searching Algorithm (`kpathsea`) as a centralized solution. This is what a very decent chunk of LaTeX tooling uses under the hood, and consequently finding a way to interop Tectonic and `kpathsea` would likely solve most problems when using external LaTeX software.

### Option 3: Qualify filenames directly in Tectonic
This is a more ambitious option, but one that can theoretically be done given enough time (call it my stretch goal). The problem here is that I still need to debug the entire Tectonic process, because I need to know where to "hook" (or alternateively, copy and slightly modify) the code when building a modified executable. Also no `gdb` on M1 makes this pain ðŸ˜”

### Option 4: Just use MacTex assets
This could avoid some pain down the line, but of all the solutions this is pretty bad. You still need to maintain 2 TeX distributions (`kpathsea` can be installed independently) and this is the same challenge as option 3, but for much less reward.

Ok, so regardless of the exact path, we should figure out how Tectonic gets a digest file name from an asset name. There's a manifest file in the Tectonic `cache` directory, and the exact same information is stored in the `CachingBundle` struct. Time to do some perfectly safe accessing of private members...
```rs
#[derive(Clone, Copy, Debug)]
pub struct FakeCachedFileInfo {
    _length: u64,
    digest: DigestData,
}

#[derive(Debug)]
pub struct FakeCachingBundle<CB: CacheBackend> {
    // the exact same structure as CachingBundle, but all fields are pub
    pub start_url: String,
    pub contents: HashMap<String, FakeCachedFileInfo>
    /// ... ///
}

fn we_do_a_bit_of_tomfoolery(cb: CachingBundle<IndexedTarBackend>) {
    let fcb: FakeCachingBundle<IndexedTarBackend> = unsafe {
        std::mem::transmute(cb)
    };
    for (k, v) in fcb.contents {
        println!("{:?} -> {:?}", k, v);
    }
}
```

```
"umsa.fd" -> FakeCachedFileInfo { _length: 961, digest: DigestData([72, 53, 94, 150, 3, 51, 190, 116, 125, 215, 180, 80, 14, 118, 253, 231, 195, 239, 11, 31, 169, 199, 78, 192, 241, 67, 138, 240, 211, 166, 97, 164]) }
"lmroman10-bolditalic.otf" -> FakeCachedFileInfo { _length: 118204, digest: DigestData([195, 122, 40, 238, 215, 166, 224, 63, 121, 43, 152, 181, 229, 246, 55, 178, 252, 218, 55, 139, 180, 133, 95, 153, 40, 79, 26, 136, 254, 53, 241, 36]) }
"hyph-mul-ethi.tex" -> FakeCachedFileInfo { _length: 12004, digest: DigestData([223, 112, 46, 236, 100, 125, 177, 107, 55, 5, 109, 120, 80, 176, 102, 251, 126, 0, 106, 12, 151, 83, 0, 110, 44, 215, 97, 241, 159, 100, 43, 255]) }
"pzdr.tfm" -> FakeCachedFileInfo { _length: 1528, digest: DigestData([107, 66, 84, 33, 120, 81, 226, 133, 209, 213, 198, 223, 230, 119, 40, 67, 150, 238, 255, 197, 159, 112, 154, 215, 117, 64, 75, 118, 220, 153, 213, 19]) }
"cmsy7.tfm" -> FakeCachedFileInfo { _length: 1120, digest: DigestData([79, 89, 187, 246, 131, 233, 71, 200, 7, 21, 134, 65, 98, 25, 130, 220, 131, 245, 95, 236, 4, 47, 234, 121, 99, 216, 206, 159, 157, 169, 130, 86]) }
"atbegshi-ltx.sty" -> FakeCachedFileInfo { _length: 3034, digest: DigestData([129, 85, 130, 169, 32, 8, 124, 58, 60, 125, 191, 77, 53, 123, 34, 219, 5, 224, 135, 248, 123, 127, 220, 173, 246, 6, 217, 241, 254, 117, 12, 180]) }
"loadhyph-nl.tex" -> FakeCachedFileInfo { _length: 1156, digest: DigestData([188, 184, 88, 81, 145, 57, 71, 67, 229, 163, 145, 162, 17, 239, 82, 11, 89, 235, 220, 201, 152, 70, 164, 192, 191, 171, 124, 249, 144, 112, 241, 239]) }
```

Let's take a wild guess as to what a 64 character hex digest could possibly mean. Well, we don't even need to take a guess, because `create_two_part_path(&self, base: &Path) -> Result<PathBuf>` makes it pretty clear that this is what we've been looking for. The unsafe memory transmute is obviously not ideal, but we can use a similar strategy of copy and pasting basically the exact same code in our own project so we can access `CachedFileInfo` and the `DigestsData` within.

A minor problem is that our file names are actually only 31 bytes instead of 32, because the first byte is the directory name. However, the [chance of collision](https://stackoverflow.com/questions/10434326/hash-collision-in-git#:~:text=Picking%20atoms%20on%2010%20Moons) is so small, we're just going to ignore that problem.

Ok, knowing what we now know, let's give the `ls-R` database a shot. First things first, we should try to just make sure `kpathsea` can see the files in our Tectonic directory. `kpsewhich` is a really great utility for debugging path searching (duh) but also TeX environment variables (which are usually declared when TeX is run, not in the environment). First, we have to declare `$TEXINPUTS` because `kpathsea` is presumably either part of our TeX Live distribution or built as a standalone file --- either way, it wouldn't otherwise be aware of our Tectonic folder.
```
(../Caches/Tectonic) $ export TEXINPUTS=~/Library/Caches/Tectonic
(../Caches/Tectonic) $ kpsewhich -debug=2 a18cfefa58132c52ce5de70db1fd1154201c19cd2b2cdaffba4906a33e6852
kdebug:db:init(): skipping db same_file_p /usr/local/texlive/texmf-local/ls-r, will add /usr/local/texlive/texmf-local/ls-R.
kdebug:db:init(): using db file /usr/local/texlive/texmf-local/ls-R.
kdebug:db:init(): skipping db same_file_p /usr/local/texlive/2022/texmf-config/ls-r, will add /usr/local/texlive/2022/texmf-config/ls-R.
kdebug:db:init(): using db file /usr/local/texlive/2022/texmf-config/ls-R.
...
kdebug:/usr/local/texlive/texmf-local/ls-R: 25 entries in 25 directories (0 hidden).
kdebug:ls-R hash table:64007 buckets, 15 nonempty (0%); 25 entries, average chain 1.7.
kdebug:/usr/local/texlive/2022/texmf-config/ls-R: 17 entries in 11 directories (0 hidden).
kdebug:ls-R hash table:64007 buckets, 29 nonempty (0%); 42 entries, average chain 1.4.
...
~/Library/Caches/Tectonic/files/1a/a18cfefa58132c52ce5de70db1fd1154201c19cd2b2cdaffba4906a33e6852
```
Most of that is useless, but we see 2 important things: one, our font file has been found, and two, our `ls-R` file has _not_ been found. After some more digging, we find that we need to also add the Tectonic directory to `$TEXMFDBS`.
```
(../Caches/Tectonic) $ export TEXMFDBS=~/Library/Caches/Tectonic
(../Caches/Tectonic) $ ls -LAR ./ > ls-R
(../Caches/Tectonic) $ kpsewhich -debug=2 a18cfefa58132c52ce5de70db1fd1154201c19cd2b2cdaffba4906a33e6852 && echo $?
...
1
```
I played around for a while and still couldn't get it to work, even though `kpsewhich` recognized my `ls-R` file. Eventually, I poked around an `ls-R` file from TeX Live and found this as the first line:
```
% ls-R -- filename database for kpathsea; do not change this line.
```
When playing around with `texhash`, I got an error referencing a "magic string" --- maybe this is it?
```
(../Caches/Tectonic) $ kpsewhich -debug=2 a18cfefa58132c52ce5de70db1fd1154201c19cd2b2cdaffba4906a33e6852
kdebug:db:init(): skipping db same_file_p ~/Library/Caches/Tectonic/ls-r, will add ~/Library/Caches/Tectonic/ls-R.
kdebug:db:init(): using db file ~/Library/Caches/Tectonic/ls-R.
kdebug:~/Library/Caches/Tectonic/ls-R: 930 entries in 244 directories (0 hidden).
kdebug:ls-R hash table:64007 buckets, 768 nonempty (1%); 930 entries, average chain 1.2.
kdebug:~/Library/Caches/Tectonic//aliases: 1 aliases.
kdebug:alias hash table:1009 buckets, 1 nonempty (0%); 1 entries, average chain 1.0.
~/Library/Caches/Tectonic/files/1a/a18cfefa58132c52ce5de70db1fd1154201c19cd2b2cdaffba4906a33e6852
```
Yes! Ok, now we're going to abuse a somewhat obscure feature of `kpathsea`: aliases. In addition to the `ls-R` database, `kpathsea` supports an `aliases` file where each entry maps a real file to an aliased name, separated by whitespace. For example:
```
a18cfefa58132c52ce5de70db1fd1154201c19cd2b2cdaffba4906a33e6852 lmroman10-regular
```
For testing, I parsed the manifest file from Tectonic using Vim macros to make an `aliases` file for testing.
Ok, let's give it a shot:
```
(../Caches/Tectonic) $ kpsewhich lmroman10-regular
~/Library/Caches/Tectonic/files/1a/a18cfefa58132c52ce5de70db1fd1154201c19cd2b2cdaffba4906a33e6852
```
Nice! Very good progress.

At this point, I hit a bit of a wall. `kpsewhich` was finding my files no problem, but `dvisvgm` (which ought to use the same `kpathsea` distro because they're both part of my TeX Live distro) couldn't find anything. Worse, it could find _some_ of the font files, but not `lmroman10-regular`. It was at this point I stumbled on a rather inconvenient truth:
```
(~/Downloads) $ tectonic -X compile -xdv example.tex
(~/Downloads) $ xdvipdfmx example.xdv
...
><lmroman10-regular@9.96pt<NATIVE-FONTMAP:/usr/local/texlive/2022/texmf-dist/fonts/opentype/public/lm/lmroman10-regular.otf/0/H/65536/0/0>(CID:LMRoman10-Regular)
pdf_font>> Type0 font "/usr/local/texlive/2022/texmf-dist/fonts/opentype/public/lm/lmroman10-regular.otf" cmap_id=<Identity-H,0> font_id=</usr/local/texlive/2022/texmf-dist/fonts/opentype/public/lm/lmroman10-regular.otf/0/H/65536/0/0,4>.
...
8104 bytes written
```
What?! `xdvipdfmx` works with the weird Tectonic XDV format? Not only that, but it used `lmroman10-regular` from TeX Live, not Tectonic. Perhaps the assumption that the Tectonic XDV was arbitrary was wrong, and `dvisvgm` actually just doesn't parse XDV well? Upon further inspection, it turns out that `dvipdfmx` and `dvipdfm` also produce correct PDF output (they are similar but different programs that generate slightly different outputs).

It was at this point I (attempted) to go big or go home, and try my hand at generating Rust bindings for patching `dvisvgm`. Unfortunately, this is not ideal, because injecting a single piece of Rust code into an enormous C++ codebase is absurd --- however, I have a final project to write (in Rust). I'll submit a C++ PR later so they can actually use my code, but for right now let's get to the juicy stuff.

Ugh... time to compare the source from `dvisvgm` and `xdvipdfmx` to see the difference. To make life easier for myself, I'm going to attempt a janky-AF trick where I will pseudo binary search for the first release of `xdvipdfmx` that will compile the Tectonic-produced XDV. I'm not even going to explain the XDV format, because the code is """self documenting""" (would it really kill the XeTeX maintainers to write a small summary of the extensions to DVI?)

Bizzarely enough, I ran the 


I came to discover the somewhat shocking truth that... Tectonic itself was not the problem, but my test $\TeX$ file was.
![](https://media.tenor.com/Oaq1HNMNDVsAAAAC/facepalm-crowd.gif)