## Presented by `Fe`tching
*(better Rust/iron pun TBA)*
- George Huebner (georgeh3)

# So Long Bevy

[![](https://img.youtube.com/vi/M1vfXoUNDYA/0.jpg)](https://www.youtube.com/watch?v=M1vfXoUNDYA)

*We've got a great name, a great team, and a GREAT name. Let's pivot!*

I have decided not to proceed with my original idea of designing a game in Bevy. There are a few reasons for this decision:

1. Bevy's ECS is cool and all, but from everything I've seen, I wouldn't really be leveraging Rust itself when making a game using an existing framework: I would be writing Bevy code, not Rust code.
    * I would really like to explore building a game from the ground up (in Rust) in the future, but this is a significantly larger endeavor than can be accomplished in a semester project.
2. The Rust gamedev ecosystem has yet to reach maturity. I, too, like to live life on the bleeding edge sometimes, but having all dependencies break each other gets very tiring very quickly.
3. I could feasibly make a prototype, but likely not one that I would actually be happy with. I knew the asset pipeline would be bad, but I underestimated that even ripping assets from existing games would still be a lot of work.

Intstead, I will be working on a compatibility layer for the Tectonic typesetting system. Why Tectonic?

1. It's open source â€” Other people can actually use my code, and it might even get merged upstream!
2. It solves a problem. I'm no stranger to building useless things, but having something hat I can benefit from motivates me to actually make the project good.
3. It uses Rust. Well, no duh, Bevy uses Rust too, but the whole purpose of Tectonic is to provide a safe, platform-independent wrapper over the $\LaTeX$ wrappers of yore. It makes sense to write this project in Rust: I can claim moral superiority over C# users now!

<br>

![](Untitled.png)


## Design Process
So, here's the main problem. This is taken from an XDV file generated by XeTeX **from MacTex**:
```/usr/local/texlive/2022/texmf-dist/fonts/opentype/public/lm/lmroman10-regular.otf```

And here is an exerpt of Tectonic's XDV (both from the same $\Latex$ source):
```lmroman10-regular```
See the issue? The XDV Tectonic generates can only be understood by Tectonic --- this makes sense, because this is how $\Latex$ is passed around internally in Tectonic. However, this XDV file is completely useless outside of Tectonic, because `lmroman10-regular` doesn't mean anything by itself. One of the cool things about Tectonic is that, like Cargo, it will automatically pull dependencies for your Latex documents from the internet when you compile your document. However, unlike most TeX distributions which store assets in a human-readable format, Tectonic instead caches <ul>all</ul> assets like Git objects. Let's compare the actual `lmroman10-regular` files on my machine between MacTex and Tectonic:
```/usr/local/texlive/2022/texmf-dist/fonts/opentype/public/lm/lmroman10-regular.otf```

```$ md5 -q /usr/local/texlive/2022/texmf-dist/fonts/opentype/public/lm/lmroman10-regular.otf
ae9d1b331000d544f47e5223081b7b54
$ for i in ~/Library/Caches/Tectonic/files/*/*; do if [ "`md5 -q $i`" = "ae9d1b331000d544f47e5223081b7b54" ]; then echo $i; fi; done
~/Library/Caches/Tectonic/files/1a/a18cfefa58132c52ce5de70db1fd1154201c19cd2b2cdaffba4906a33e6852
```
This tells us one good piece of news that makes our lives easier: the assets are identical in both MacTex and Tectonic.

#### Option 1: Try and overwrite filepath in XDV manually
This *might* work if you put enough effort in, but editing binary files is usually a very bad idea if you don't know exactly what you're doing. The XDV specicication is really scuffed, too (I had an easier time reverse engineering a [closed-source tractor trailer logging protocol](https://www.sae.org/publications/collections/content/j1939_dl/)).

### Option 2: `ls-r` database craziness
Buckle your seatbelts, because we're about to go take a trip on the magic schoolbus back to the wild west of the early days of Tex. Back in the 90s, every TeX library used their own path searching algorithm (many of which were error prone), so Karl Berry made Karl's Path Searching Algorithm (`kpathsea`) as a centralized solution. This is what a very decent chunk of LateX tooling uses under the hood, and consequently finding a way to interop Tectonic and `kpathsea` would likely solve most problems when using external LaTeX software.

### Option 3: Qualify filenames directly in Tectonic
This is a more ambitious option, but one that can theoretically be done given enough time (call it my stretch goal). The problem here is that I still need to debug the entire Tectonic process, because I need to know where to "hook" (or alternateively, copy and slightly modify) the code when building a modified executable. Also no `gdb` on M1 makes this pain ðŸ˜”

### Option 4: Just use MacTex assets
This could avoid some pain down the line, but of all the solutions this is pretty bad. You still need to maintain 2 TeX distributions (`kpathsea` can be installed independently) and this is the same challenge as option 3, but for much less reward.

Ok, so regardless of the exact path, we should figure out how Tectonic gets a digest file name from an asset name. There's a manifest file in the Tectonic `cache` directory, and the exact same information is stored in the `CachingBundle` struct. Time to do some perfectly safe accessing of private members...
```rs
#[derive(Clone, Copy, Debug)]
pub struct FakeCachedFileInfo {
    _length: u64,
    digest: DigestData,
}

#[derive(Debug)]
pub struct FakeCachingBundle<CB: CacheBackend> {
    // the exact same structure as CachingBundle, but all fields are pub
    pub start_url: String,
    pub contents: HashMap<String, FakeCachedFileInfo>
    /// ... ///
}

fn we_do_a_bit_of_tomfoolery(cb: CachingBundle<IndexedTarBackend>) {
    let fcb: FakeCachingBundle<IndexedTarBackend> = unsafe {
        std::mem::transmute(cb)
    };
    for (k, v) in fcb.contents {
        println!("{:?} -> {:?}", k, v);
    }
}
```

```
"umsa.fd" -> FakeCachedFileInfo { _length: 961, digest: DigestData([72, 53, 94, 150, 3, 51, 190, 116, 125, 215, 180, 80, 14, 118, 253, 231, 195, 239, 11, 31, 169, 199, 78, 192, 241, 67, 138, 240, 211, 166, 97, 164]) }
"lmroman10-bolditalic.otf" -> FakeCachedFileInfo { _length: 118204, digest: DigestData([195, 122, 40, 238, 215, 166, 224, 63, 121, 43, 152, 181, 229, 246, 55, 178, 252, 218, 55, 139, 180, 133, 95, 153, 40, 79, 26, 136, 254, 53, 241, 36]) }
"hyph-mul-ethi.tex" -> FakeCachedFileInfo { _length: 12004, digest: DigestData([223, 112, 46, 236, 100, 125, 177, 107, 55, 5, 109, 120, 80, 176, 102, 251, 126, 0, 106, 12, 151, 83, 0, 110, 44, 215, 97, 241, 159, 100, 43, 255]) }
"pzdr.tfm" -> FakeCachedFileInfo { _length: 1528, digest: DigestData([107, 66, 84, 33, 120, 81, 226, 133, 209, 213, 198, 223, 230, 119, 40, 67, 150, 238, 255, 197, 159, 112, 154, 215, 117, 64, 75, 118, 220, 153, 213, 19]) }
"cmsy7.tfm" -> FakeCachedFileInfo { _length: 1120, digest: DigestData([79, 89, 187, 246, 131, 233, 71, 200, 7, 21, 134, 65, 98, 25, 130, 220, 131, 245, 95, 236, 4, 47, 234, 121, 99, 216, 206, 159, 157, 169, 130, 86]) }
"atbegshi-ltx.sty" -> FakeCachedFileInfo { _length: 3034, digest: DigestData([129, 85, 130, 169, 32, 8, 124, 58, 60, 125, 191, 77, 53, 123, 34, 219, 5, 224, 135, 248, 123, 127, 220, 173, 246, 6, 217, 241, 254, 117, 12, 180]) }
"loadhyph-nl.tex" -> FakeCachedFileInfo { _length: 1156, digest: DigestData([188, 184, 88, 81, 145, 57, 71, 67, 229, 163, 145, 162, 17, 239, 82, 11, 89, 235, 220, 201, 152, 70, 164, 192, 191, 171, 124, 249, 144, 112, 241, 239]) }
```

Let's take a wild guess as to what a 64 character hex digest could possibly mean. Well, we don't even need to take a guess, because `create_two_part_path(&self, base: &Path) -> Result<PathBuf>` makes it pretty clear that this is what we've been looking for. The unsafe memory transmute is obviously not ideal, but we can use a similar strategy of copy and pasting basically the exact same code in our own project so we can access `CachedFileInfo` and the `DigestsData` within.

Ok, knowing what we now know, let's give the `ls-r` database a shot.


Ok, this is really scuffed (and probably pretty slow), but let's give it a shot:


A minor problem is that our file names are actually only 31 bytes instead of 32, because the first bytes is the directory name. However, the [chance of collision](https://stackoverflow.com/questions/10434326/hash-collision-in-git#:~:text=Picking%20atoms%20on%2010%20Moons) is so small, we're just going to ignore that problem.